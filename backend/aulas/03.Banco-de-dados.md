---
marp: true
class:
  - invert
  - lead
paginate: true
header: 'Aula: Banco de Dados com Node.js'
---

# **Manipula√ß√£o de Banco de Dados com Node.js**
### Do SQLite aos ORMs e NoSQL


---

## **1. Introdu√ß√£o aos Bancos de Dados**

---

### **O que √© um Banco de Dados?**

√â uma **cole√ß√£o organizada de dados**, armazenada e acessada eletronicamente.

- **Persist√™ncia:** Os dados n√£o se perdem ao desligar a aplica√ß√£o.
- **Gerenciamento:** Permite criar, ler, atualizar e deletar dados de forma eficiente.
- **Seguran√ßa:** Controla o acesso √†s informa√ß√µes.

---

### **Bancos Relacionais (SQL)**

- **Estrutura:** Tabelas com linhas e colunas.
- **Esquema:** R√≠gido, definido antes de inserir os dados.
- **Linguagem:** SQL (Structured Query Language).
- **Garantia:** Consist√™ncia (propriedades ACID).
- **Exemplos:** PostgreSQL, MySQL, SQL Server, **SQLite**.


---

### **Bancos N√£o Relacionais (NoSQL)**

- **Estrutura:** Flex√≠vel (documentos, chave-valor, etc.).
- **Esquema:** Din√¢mico ou inexistente.
- **Linguagem:** APIs pr√≥prias de consulta.
- **Garantia:** Alta performance e escalabilidade.
- **Exemplos:** MongoDB, Redis, Cassandra, Neo4j.


---

### **Por que SQLite?**

- **Simples:** N√£o precisa de um servidor. O banco √© um √∫nico arquivo.
- **Leve:** F√°cil de configurar e usar.
- **Ideal para:**
    - Aprendizado e estudos.
    - Prototipagem r√°pida.
    - Aplica√ß√µes de pequeno e m√©dio porte.

---

## **2. Parte 1: `sqlite3` no Node.js**
### (A forma "pura")

---

### **Configura√ß√£o do Ambiente**

1. **Iniciar o projeto:**
```bash
   mkdir node-sqlite-aula
   cd node-sqlite-aula
   npm init -y
```
---
2.  **Instalar o driver:**
    ```bash
    npm install sqlite3
    ```

---


### **Conectando e Criando a Tabela**

```javascript
// init-db.js
const sqlite3 = require('sqlite3').verbose();
const db = new sqlite3.Database('./database.db');

db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT NOT NULL UNIQUE
    )
  `);
  console.log('Tabela "usuarios" criada ou j√° existente.');
  db.close();
});
```

**Para executar:** `node init-db.js`

-----

### **Opera√ß√µes CRUD: Create (Criar)**

```javascript
// app.js
const db = require('./database.js');

const nome = 'Alice';
const email = 'alice@example.com';
const sql = `INSERT INTO usuarios (nome, email) VALUES (?, ?)`;

db.run(sql, [nome, email], function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Usu√°rio criado com o ID: ${this.lastID}`);
});
```

-----

### **Opera√ß√µes CRUD: Read (Ler)**

```javascript
const sql = `SELECT * FROM usuarios`;

db.all(sql, [], (err, rows) => {
  if (err) {
    return console.error(err.message);
  }
  console.log('Usu√°rios cadastrados:');
  rows.forEach((row) => {
    console.log(`- ${row.id}: ${row.nome} (${row.email})`);
  });
});
```

-----

### **Opera√ß√µes CRUD: Update (Atualizar)**

```javascript
const novoNome = 'Alice Silva';
const id = 1;
const sql = `UPDATE usuarios SET nome = ? WHERE id = ?`;

db.run(sql, [novoNome, id], function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Linhas afetadas: ${this.changes}`);
});
```

-----

### **Opera√ß√µes CRUD: Delete (Deletar)**

```javascript
const id = 2;
const sql = `DELETE FROM usuarios WHERE id = ?`;

db.run(sql, id, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Linhas afetadas: ${this.changes}`);
});
```

-----

## **3. O que s√£o ORMs?**

### Object-Relational Mapping

-----

### **O Conceito de ORM**

Um ORM √© uma "ponte" que traduz o c√≥digo que voc√™ escreve (objetos, classes) em comandos SQL que o banco de dados entende.

**Voc√™ manipula objetos, o ORM manipula o SQL.**

`Objeto Usuario` \<--\> `ORM` \<--\> `Tabela usuarios`

-----

### **Vantagens vs. Desvantagens**

**Vantagens üëç**

  - **Produtividade:** Menos c√≥digo SQL repetitivo.
  - **Portabilidade:** Troque de banco (SQLite -\> PostgreSQL) com poucas altera√ß√µes.
  - **Seguran√ßa:** Ajuda a prevenir SQL Injection.
  - **C√≥digo mais leg√≠vel** e orientado a objetos.

**Desvantagens üëé**

  - **Curva de Aprendizagem:** √â uma nova ferramenta para aprender.
  - **Performance:** Pode gerar SQL menos otimizado em casos complexos.
  - **Abstra√ß√£o "vazada":** √Äs vezes, voc√™ ainda precisa escrever SQL puro.

-----

## **4. ORM com Sequelize**

-----

##### **Sequelize: Instala√ß√£o e Configura√ß√£o**

1.  **Instalar pacotes:**
    ```bash
    npm install sequelize sqlite3
    ```
2.  **Configurar conex√£o:**
    ```javascript
    // sequelize.js
    const { Sequelize } = require('sequelize');

    const sequelize = new Sequelize({
      dialect: 'sqlite',
      storage: './database-sequelize.db'
    });

    module.exports = sequelize;
    ```

-----

##### **Sequelize: Definindo um Modelo**

Um "Modelo" representa uma tabela no banco.

```javascript
// models/usuario.js
const { DataTypes } = require('sequelize');
const sequelize = require('../sequelize');

const Usuario = sequelize.define('Usuario', {
  nome: {
    type: DataTypes.STRING,
    allowNull: false
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  }
}, { tableName: 'usuarios' });

module.exports = Usuario;
```

-----

#### **Sequelize: Sincronizando e Usando**

O m√©todo `.sync()` cria a tabela se ela n√£o existir.

---

```javascript
const sequelize = require('./sequelize');
const Usuario = require('./models/usuario');

async function main() {
  await sequelize.sync({ force: true }); // Cuidado em produ√ß√£o!

  // --- CREATE ---
  const user = await Usuario.create({ nome: 'Carlos', email: 'carlos@email.com' });

  // --- READ ---
  const usuarios = await Usuario.findAll();
  console.log(usuarios.map(u => u.toJSON()));

  // --- UPDATE ---
  await Usuario.update({ nome: 'Carlos Souza' }, { where: { id: 1 } });

  // --- DELETE ---
  await Usuario.destroy({ where: { id: 1 } });
}

main();
```

-----

## **5. ORM com Prisma**

-----

### **Prisma: Uma abordagem moderna**

Prisma n√£o √© um ORM tradicional. Ele usa um arquivo de **schema** para gerar um **cliente de banco de dados** otimizado e totalmente tipado.

1.  **Instala√ß√£o:**
    ```bash
    npm install prisma --save-dev
    npm install @prisma/client
    ```
2.  **Inicializa√ß√£o:**
    ```bash
    npx prisma init --datasource-provider sqlite
    ```
    Isso cria a pasta `prisma/` e o arquivo `schema.prisma`.

-----

### **Prisma: Definindo o Schema**

Voc√™ descreve seus modelos no arquivo `prisma/schema.prisma`.

```prisma
// prisma/schema.prisma
datasource db {
  provider = "sqlite"
  url      = "file:./database-prisma.db"
}

generator client {
  provider = "prisma-client-js"
}

model Usuario {
  id    Int     @id @default(autoincrement())
  email String  @unique
  nome  String? // ? = opcional
}
```

-----

### **Prisma: Migra√ß√£o e Gera√ß√£o**

Com o schema definido, voc√™ aplica as mudan√ßas no banco com `migrate`.

```bash
# Cria a migra√ß√£o e aplica no banco
npx prisma migrate dev --name init
```

Este comando:

1.  Salva a mudan√ßa do schema.
2.  Cria/atualiza o banco de dados.
3.  **Gera o Prisma Client** para voc√™ usar no c√≥digo.

-----

### **Prisma: Opera√ß√µes CRUD**

O c√≥digo fica limpo, leg√≠vel e seguro contra erros de digita√ß√£o (com TS).

---

```javascript
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function main() {
  // --- CREATE ---
  const user = await prisma.usuario.create({
    data: { nome: 'Fernanda', email: 'fernanda@email.com' },
  });

  // --- READ ---
  const usuarios = await prisma.usuario.findMany();

  // --- UPDATE ---
  await prisma.usuario.update({
    where: { email: 'fernanda@email.com' },
    data: { nome: 'Fernanda Lima' },
  });

  // --- DELETE ---
  await prisma.usuario.delete({ where: { id: 1 } });
}

main().finally(() => prisma.$disconnect());
```

-----

## **6. ORM com TypeORM**

-----

### **TypeORM: Ideal para TypeScript**

TypeORM utiliza **Decorators** para definir entidades, integrando-se perfeitamente com o sistema de tipos do TypeScript.

1.  **Instala√ß√£o:**

    ```bash
    npm install typeorm sqlite3 reflect-metadata
    # E para o ambiente TS:
    npm install typescript ts-node @types/node --save-dev
    ```

2.  **Configura√ß√£o da Conex√£o (`DataSource`):**
    √â onde se define o tipo de banco, caminho e entidades.

-----

### **TypeORM: Definindo uma Entidade**

Usa-se classes e decorators para mapear a tabela.

```typescript
// src/entity/Usuario.ts
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity({ name: 'usuarios' }) // Mapeia para a tabela 'usuarios'
export class Usuario {

    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    nome: string;

    @Column({ unique: true })
    email: string;
}
```

-----

### **TypeORM: Opera√ß√µes CRUD**

As opera√ß√µes s√£o feitas atrav√©s de um "reposit√≥rio" da entidade.

---

```typescript
import { AppDataSource } from "./data-source";
import { Usuario } from "./entity/Usuario";

AppDataSource.initialize().then(async () => {
    const repo = AppDataSource.getRepository(Usuario);

    // --- CREATE ---
    const user = new Usuario();
    user.nome = "Isabela";
    user.email = "isabela@email.com";
    await repo.save(user);

    // --- READ ---
    const usuarios = await repo.find();

    // --- UPDATE ---
    const userToUpdate = await repo.findOneBy({ id: 1 });
    if (userToUpdate) {
        userToUpdate.nome = "Isabela Rocha";
        await repo.save(userToUpdate);
    }
    // --- DELETE ---
    await repo.delete(1);
});
```

-----

## **7. Bancos N√£o Relacionais (NoSQL)**

### Um outro universo

-----

### **Principais Tipos de NoSQL**

  * **Documentos (MongoDB)**

      * Armazena dados em JSON/BSON. Flex√≠vel e intuitivo.
      * `{ "nome": "Jo√£o", "interesses": ["dev", "m√∫sica"] }`

  * **Chave-Valor (Redis)**

      * O mais simples: uma chave √∫nica aponta para um valor. Extremamente r√°pido.
      * `"user:123": "{'nome':'Ana', 'sessao':'xyz'}"`

---

  * **Coluna Larga (Cassandra)**

      * Otimizado para consultas em massas de dados (Big Data, IoT).

  * **Grafos (Neo4j)**

      * Perfeito para dados com muitos relacionamentos (redes sociais, recomenda√ß√µes).

-----

## **Conclus√£o**


### **Qual ferramenta usar?**

  - **`sqlite3` (SQL Puro):** Para entender os fundamentos ou para scripts simples onde performance total √© cr√≠tica.
  - **Sequelize:** Um ORM tradicional, maduro e com grande ecossistema. √ìtimo para projetos legados ou quem prefere o padr√£o Active Record.
  - **Prisma:** Moderno, focado em DX (Developer Experience) e seguran√ßa de tipos. Excelente para novos projetos, especialmente com TypeScript.
  - **TypeORM:** A escolha natural para projetos robustos em TypeScript, usando decorators para uma integra√ß√£o profunda.

**N√£o existe "o melhor", existe o mais adequado para o seu problema\!**

---

# Perguntas?
