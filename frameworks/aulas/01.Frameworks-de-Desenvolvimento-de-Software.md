---
marp: true
theme: default
paginate: true
class: lead
---

# A Evolução dos Frameworks de Desenvolvimento de Software

---

## Introdução: Descomplicando os Frameworks

- No desenvolvimento de software, eficiência, padronização e agilidade são essenciais.
- Os frameworks surgem como "esqueletos" reutilizáveis para facilitar o desenvolvimento.
- Evitam que cada projeto comece do zero.

---

## Por que usar frameworks?

- **Padronização**: Impõem arquitetura e fluxo de trabalho.
- **Produtividade**: Reduzem código repetitivo.
- **Manutenção facilitada**: Código modular e organizado.
- Ex: como usar uma planta arquitetônica para construir uma casa — mais seguro e rápido.

---

## Uma Breve História: Da Repetição à Reutilização

- Anos 1970–1980: Códigos repetitivos para tarefas comuns.
- Anos 1990: POO e padrões de projeto → surgimento de frameworks.
- Popularização do padrão **MVC**:
  - **Model**: lógica de negócio e dados.
  - **View**: interface com o usuário.
  - **Controller**: coordena ações entre Model e View.

---

## Internet e a explosão das aplicações web

- Softwares se tornaram mais complexos e interativos.
- Frameworks passaram a fornecer:
  - Roteamento
  - Autenticação
  - Conexão com banco de dados
  - Componentização da UI

---

## Java: A Robustez do Spring Framework

- **Java EE**: poderosa, mas complexa e pesada.
- **2003**: Rod Johnson lança "Expert One-on-One J2EE Design and Development".
- **2004**: nasce o **Spring Framework**.
  - Foco em simplicidade, modularidade e testabilidade.
  - Introduz **IoC (Inversão de Controle)** e **DI (Injeção de Dependência)**.
- Spring se torna o padrão em backends corporativos com Java.
- 🌐 [spring.io](https://spring.io)

---

# O que é um Framework?

- Um conjunto de ferramentas e bibliotecas que facilitam o desenvolvimento de software.
- Fornece uma estrutura padrão para a construção e a implementação de aplicações.
- Reduz a repetição de código e melhora a produtividade.

---

# Frameworks Populares

---

### Frontend:
- 🌐 [Angular](https://angular.io)
- 🌐 [Vue.js](https://vuejs.org)

---

### Backend:
- 🌐 [Django](https://www.djangoproject.com)
- 🌐 [Ruby on Rails](https://rubyonrails.org)
- 🌐 [Spring Boot](https://spring.io/projects/spring-boot)
- 🌐 [Laravel](https://laravel.com)
- 🌐 [AdonisJS](https://adonisjs.com)
- 🌐 [Express.js](https://expressjs.com)
- 🌐 [NestJS](https://nestjs.com)
- 🌐 [Koa.js](https://koajs.com)

---

### Mobile:
- 🌐 [Flutter](https://flutter.dev)
- 🌐 [React Native](https://reactnative.dev)
- 🌐 [Xamarin](https://learn.microsoft.com/en-us/xamarin/)

---

### Full-Stack:
- 🌐 [Next.js](https://nextjs.org)
- 🌐 [Laravel](https://laravel.com)
- 🌐 [Symfony](https://symfony.com)
- 🌐 [CodeIgniter](https://codeigniter.com)

---

# Frameworks Opinativos vs Não Opinativos

---

- **Opinativo:**
  - Fornece uma maneira específica e geralmente restrita de construir aplicações.
  - Promove convenções que devem ser seguidas.
  - Pode aumentar a produtividade ao reduzir a necessidade de decisões arquiteturais.

---

- **Não Opinativo:**
  - Oferece mais liberdade ao desenvolvedor para decidir como estruturar e organizar o código.
  - Mais flexível, mas pode exigir mais esforço para configurar e manter.
  - Ideal para projetos onde requisitos personalizados são necessários.

---

# Frameworks Opinativos

---

## Ruby on Rails

- **Linguagem:** Ruby
- **Arquitetura:** MVC
- **Prós:** Convenção sobre configuração, produtividade.
- **Contras:** Restritivo e menor performance.
- **Melhor uso:** MVPs, startups, CRUDs.
- 🌐 [rubyonrails.org](https://rubyonrails.org)

---

## Django

- **Linguagem:** Python
- **Arquitetura:** MTV
- **Prós:** Segurança, ferramentas integradas.
- **Contras:** Estrutura rígida.
- **Melhor uso:** Aplicações web complexas.
- 🌐 [djangoproject.com](https://www.djangoproject.com)

---

## Laravel

- **Linguagem:** PHP
- **Arquitetura:** MVC
- **Prós:** Sintaxe elegante, ecossistema rico.
- **Contras:** Pode ser pesado.
- **Melhor uso:** Sistemas completos em PHP.
- 🌐 [laravel.com](https://laravel.com)

---

## AdonisJS

- **Linguagem:** JavaScript (Node.js)
- **Arquitetura:** MVC
- **Prós:** Inspirado no Laravel, integração com Node.
- **Contras:** Menor comunidade.
- **Melhor uso:** Web apps Node estruturados.
- 🌐 [adonisjs.com](https://adonisjs.com)

---

## Next.js

- **Linguagem:** JavaScript / TypeScript
- **Baseado em:** React
- **Prós:**
  - Renderização híbrida: SSR, SSG e ISR.
  - Roteamento automático baseado em arquivos.
  - Suporte a API Routes e Full-Stack.
---

- **Contras:**
  - Curva de aprendizado para novos devs.
  - Maior complexidade em projetos grandes.
- **Melhor uso:**
  - Aplicações web modernas com SEO e performance.
- 🌐 [nextjs.org](https://nextjs.org)

---

# Frameworks Não Opinativos

---

## Express.js

* **Linguagem:** JavaScript
* **Arquitetura:** Flexível
* **Prós:** Leve, grande ecossistema.
* **Contras:** Pouca estrutura, manutenção difícil em grandes projetos.
* **Melhor uso:** APIs RESTful, microserviços.
* 🌐 [expressjs.com](https://expressjs.com)

---

## NestJS

* **Linguagem:** TypeScript
* **Arquitetura:** Modular
* **Prós:** Escalável, com suporte a microserviços.
* **Contras:** Mais complexo que Express.
* **Melhor uso:** Backends corporativos.
* 🌐 [nestjs.com](https://nestjs.com)

---

## Koa.js

* **Linguagem:** JavaScript
* **Arquitetura:** Flexível
* **Prós:** Mais moderno que Express, leve.
* **Contras:** Menor comunidade.
* **Melhor uso:** Aplicações com foco em performance.
* 🌐 [koajs.com](https://koajs.com)

---

## Symfony

* **Linguagem:** PHP
* **Arquitetura:** MVC
* **Prós:** Flexível e robusto.
* **Contras:** Curva de aprendizado alta.
* **Melhor uso:** Projetos empresariais em PHP.
* 🌐 [symfony.com](https://symfony.com)

---

# Conclusão

* Frameworks aceleram o desenvolvimento e promovem boas práticas.
* A escolha depende do tipo de projeto, da equipe e da escalabilidade.
* Cada linguagem possui ecossistemas maduros e frameworks com abordagens únicas.
