---
marp: true
theme: default
paginate: true
class: lead
---

# A EvoluÃ§Ã£o dos Frameworks de Desenvolvimento de Software

---

## IntroduÃ§Ã£o: Descomplicando os Frameworks

- No desenvolvimento de software, eficiÃªncia, padronizaÃ§Ã£o e agilidade sÃ£o essenciais.
- Os frameworks surgem como "esqueletos" reutilizÃ¡veis para facilitar o desenvolvimento.
- Evitam que cada projeto comece do zero.

---

## Por que usar frameworks?

- **PadronizaÃ§Ã£o**: ImpÃµem arquitetura e fluxo de trabalho.
- **Produtividade**: Reduzem cÃ³digo repetitivo.
- **ManutenÃ§Ã£o facilitada**: CÃ³digo modular e organizado.
- Ex: como usar uma planta arquitetÃ´nica para construir uma casa â€” mais seguro e rÃ¡pido.

---

## Uma Breve HistÃ³ria: Da RepetiÃ§Ã£o Ã  ReutilizaÃ§Ã£o

- Anos 1970â€“1980: CÃ³digos repetitivos para tarefas comuns.
- Anos 1990: POO e padrÃµes de projeto â†’ surgimento de frameworks.
- PopularizaÃ§Ã£o do padrÃ£o **MVC**:
  - **Model**: lÃ³gica de negÃ³cio e dados.
  - **View**: interface com o usuÃ¡rio.
  - **Controller**: coordena aÃ§Ãµes entre Model e View.

---

## Internet e a explosÃ£o das aplicaÃ§Ãµes web

- Softwares se tornaram mais complexos e interativos.
- Frameworks passaram a fornecer:
  - Roteamento
  - AutenticaÃ§Ã£o
  - ConexÃ£o com banco de dados
  - ComponentizaÃ§Ã£o da UI

---

## Java: A Robustez do Spring Framework

- **Java EE**: poderosa, mas complexa e pesada.
- **2003**: Rod Johnson lanÃ§a "Expert One-on-One J2EE Design and Development".
- **2004**: nasce o **Spring Framework**.
  - Foco em simplicidade, modularidade e testabilidade.
  - Introduz **IoC (InversÃ£o de Controle)** e **DI (InjeÃ§Ã£o de DependÃªncia)**.
- Spring se torna o padrÃ£o em backends corporativos com Java.
- ğŸŒ [spring.io](https://spring.io)

---

# O que Ã© um Framework?

- Um conjunto de ferramentas e bibliotecas que facilitam o desenvolvimento de software.
- Fornece uma estrutura padrÃ£o para a construÃ§Ã£o e a implementaÃ§Ã£o de aplicaÃ§Ãµes.
- Reduz a repetiÃ§Ã£o de cÃ³digo e melhora a produtividade.

---

# Frameworks Populares

---

### Frontend:
- ğŸŒ [Angular](https://angular.io)
- ğŸŒ [Vue.js](https://vuejs.org)

---

### Backend:
- ğŸŒ [Django](https://www.djangoproject.com)
- ğŸŒ [Ruby on Rails](https://rubyonrails.org)
- ğŸŒ [Spring Boot](https://spring.io/projects/spring-boot)
- ğŸŒ [Laravel](https://laravel.com)
- ğŸŒ [AdonisJS](https://adonisjs.com)
- ğŸŒ [Express.js](https://expressjs.com)
- ğŸŒ [NestJS](https://nestjs.com)
- ğŸŒ [Koa.js](https://koajs.com)

---

### Mobile:
- ğŸŒ [Flutter](https://flutter.dev)
- ğŸŒ [React Native](https://reactnative.dev)
- ğŸŒ [Xamarin](https://learn.microsoft.com/en-us/xamarin/)

---

### Full-Stack:
- ğŸŒ [Next.js](https://nextjs.org)
- ğŸŒ [Laravel](https://laravel.com)
- ğŸŒ [Symfony](https://symfony.com)
- ğŸŒ [CodeIgniter](https://codeigniter.com)

---

# Frameworks Opinativos vs NÃ£o Opinativos

---

- **Opinativo:**
  - Fornece uma maneira especÃ­fica e geralmente restrita de construir aplicaÃ§Ãµes.
  - Promove convenÃ§Ãµes que devem ser seguidas.
  - Pode aumentar a produtividade ao reduzir a necessidade de decisÃµes arquiteturais.

---

- **NÃ£o Opinativo:**
  - Oferece mais liberdade ao desenvolvedor para decidir como estruturar e organizar o cÃ³digo.
  - Mais flexÃ­vel, mas pode exigir mais esforÃ§o para configurar e manter.
  - Ideal para projetos onde requisitos personalizados sÃ£o necessÃ¡rios.

---

# Frameworks Opinativos

---

## Ruby on Rails

- **Linguagem:** Ruby
- **Arquitetura:** MVC
- **PrÃ³s:** ConvenÃ§Ã£o sobre configuraÃ§Ã£o, produtividade.
- **Contras:** Restritivo e menor performance.
- **Melhor uso:** MVPs, startups, CRUDs.
- ğŸŒ [rubyonrails.org](https://rubyonrails.org)

---

## Django

- **Linguagem:** Python
- **Arquitetura:** MTV
- **PrÃ³s:** SeguranÃ§a, ferramentas integradas.
- **Contras:** Estrutura rÃ­gida.
- **Melhor uso:** AplicaÃ§Ãµes web complexas.
- ğŸŒ [djangoproject.com](https://www.djangoproject.com)

---

## Laravel

- **Linguagem:** PHP
- **Arquitetura:** MVC
- **PrÃ³s:** Sintaxe elegante, ecossistema rico.
- **Contras:** Pode ser pesado.
- **Melhor uso:** Sistemas completos em PHP.
- ğŸŒ [laravel.com](https://laravel.com)

---

## AdonisJS

- **Linguagem:** JavaScript (Node.js)
- **Arquitetura:** MVC
- **PrÃ³s:** Inspirado no Laravel, integraÃ§Ã£o com Node.
- **Contras:** Menor comunidade.
- **Melhor uso:** Web apps Node estruturados.
- ğŸŒ [adonisjs.com](https://adonisjs.com)

---

## Next.js

- **Linguagem:** JavaScript / TypeScript
- **Baseado em:** React
- **PrÃ³s:**
  - RenderizaÃ§Ã£o hÃ­brida: SSR, SSG e ISR.
  - Roteamento automÃ¡tico baseado em arquivos.
  - Suporte a API Routes e Full-Stack.
---

- **Contras:**
  - Curva de aprendizado para novos devs.
  - Maior complexidade em projetos grandes.
- **Melhor uso:**
  - AplicaÃ§Ãµes web modernas com SEO e performance.
- ğŸŒ [nextjs.org](https://nextjs.org)

---

# Frameworks NÃ£o Opinativos

---

## Express.js

* **Linguagem:** JavaScript
* **Arquitetura:** FlexÃ­vel
* **PrÃ³s:** Leve, grande ecossistema.
* **Contras:** Pouca estrutura, manutenÃ§Ã£o difÃ­cil em grandes projetos.
* **Melhor uso:** APIs RESTful, microserviÃ§os.
* ğŸŒ [expressjs.com](https://expressjs.com)

---

## NestJS

* **Linguagem:** TypeScript
* **Arquitetura:** Modular
* **PrÃ³s:** EscalÃ¡vel, com suporte a microserviÃ§os.
* **Contras:** Mais complexo que Express.
* **Melhor uso:** Backends corporativos.
* ğŸŒ [nestjs.com](https://nestjs.com)

---

## Koa.js

* **Linguagem:** JavaScript
* **Arquitetura:** FlexÃ­vel
* **PrÃ³s:** Mais moderno que Express, leve.
* **Contras:** Menor comunidade.
* **Melhor uso:** AplicaÃ§Ãµes com foco em performance.
* ğŸŒ [koajs.com](https://koajs.com)

---

## Symfony

* **Linguagem:** PHP
* **Arquitetura:** MVC
* **PrÃ³s:** FlexÃ­vel e robusto.
* **Contras:** Curva de aprendizado alta.
* **Melhor uso:** Projetos empresariais em PHP.
* ğŸŒ [symfony.com](https://symfony.com)

---

# ConclusÃ£o

* Frameworks aceleram o desenvolvimento e promovem boas prÃ¡ticas.
* A escolha depende do tipo de projeto, da equipe e da escalabilidade.
* Cada linguagem possui ecossistemas maduros e frameworks com abordagens Ãºnicas.
