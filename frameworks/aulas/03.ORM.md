---
marp: true
theme: default
class: invert
---

# üöÄ ORM com Node.js

---

## üß† 1. Conceitos Fundamentais de ORM

- **O que √© um ORM?**
  - **O**bject-**R**elational **M**apping (Mapeamento Objeto-Relacional).
  - Uma camada de **abstra√ß√£o** que atua como **tradutor** entre o c√≥digo orientado a objetos (JS/TS) e o banco de dados relacional (SQL).

---

- **O Problema que Resolve**
  - **Antes do ORM**: Escrever SQL puro no c√≥digo.
    - `const query = "INSERT INTO books (title, author) VALUES (?, ?)"`
    - Risco de SQL Injection.
    - Verboso e repetitivo.
    - Acoplamento com o dialeto SQL espec√≠fico (MySQL, PostgreSQL, etc.).

---

- **Com o ORM**: Usar m√©todos e objetos da pr√≥pria linguagem.
  - `await Book.create({ title: '...', author: '...' })`

---

- **Vantagens Principais**
  - **Aumento de Produtividade**: Menos c√≥digo para escrever. Foco na regra de neg√≥cio.
  - **Independ√™ncia do Banco de Dados**: Trocar de SQLite para PostgreSQL exige mudan√ßa m√≠nima (apenas na configura√ß√£o da conex√£o).
  - **Seguran√ßa**: Preven√ß√£o autom√°tica contra SQL Injection na maioria das opera√ß√µes.
  - **C√≥digo Mais Limpo e Leg√≠vel**: A manipula√ß√£o de dados se assemelha √† manipula√ß√£o de objetos comuns.
  - **Recursos Avan√ßados**: Gest√£o de **migra√ß√µes** (versionamento do schema do DB), **transa√ß√µes** e **relacionamentos complexos** (1:1, 1:N, N:M).

---

## üìö 2. Foco Principal: Sequelize + SQLite

- ### ‚öôÔ∏è 2.1. Configura√ß√£o do Ambiente
  - **1. Iniciar o projeto Node.js**
    - `mkdir aula-biblioteca`
    - `cd aula-biblioteca`
    - `npm init -y` (Cria o `package.json`)
  - **2. Instalar depend√™ncias**
    - **Sequelize**: O ORM em si.
    - **SQLite3**: O "driver" que permite ao Sequelize "falar" com o SQLite.
    - `npm install sequelize sqlite3`

---

- ### üîå 2.2. Conex√£o com o Banco

  - Criar o arquivo `database.js`.
  - O SQLite √© um banco de dados "serverless", ele funciona com um √∫nico arquivo no seu projeto.
  - ```javascript
    // database.js
    const { Sequelize } = require('sequelize');

    const sequelize = new Sequelize({
      dialect: 'sqlite',
      storage: 'biblioteca.sqlite', // Nome do arquivo do banco
    });

    module.exports = sequelize;
    ```

---

- ### üìñ 2.3. Defini√ß√£o do Modelo `Book`
  - Um **Modelo** (Model) representa uma **tabela** no banco de dados.
  - Criar o arquivo `book.js`.

---

- ```javascript
  // book.js
  const { DataTypes } = require('sequelize');
  const sequelize = require('./database');

  const Book = sequelize.define('Book', {
    // Atributos (colunas da tabela)
    title: {
      type: DataTypes.STRING,
      allowNull: false, // NOT NULL
    },
    author: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    publicationYear: {
      type: DataTypes.INTEGER,
    },
    isbn: {
      type: DataTypes.STRING,
      unique: true, // Garante que n√£o haja ISBNs duplicados
    },
    // O Sequelize cria 'id', 'createdAt' e 'updatedAt' por padr√£o.
  });

  module.exports = Book;
  ```

---

- ### ‚ú® 2.4. Sincroniza√ß√£o
  - √â o processo de criar a estrutura da tabela no banco de dados com base no modelo definido.
  - **`sequelize.sync()`**: Compara os modelos definidos no c√≥digo com o banco de dados e cria as tabelas que n√£o existem.
    - **`{ force: true }`**: **Aten√ß√£o!** Apaga a tabela se ela j√° existir e a recria do zero. **√ötil apenas em desenvolvimento** para testar altera√ß√µes no modelo. Em produ√ß√£o, usa-se **migrations**.

---

- ```javascript
  // index.js
  const sequelize = require('./database');
  const Book = require('./book');

  async function setup() {
    await sequelize.sync({ force: true });
    console.log('Tabela de livros (re)criada!');
  }
  setup();
  ```

---

- ### üîÑ 2.5. Opera√ß√µes CRUD (Create, Read, Update, Delete)
  - **CREATE (Criar)**: Adicionar um novo registro.
    - Usa o m√©todo `Model.create()`.
    - ```javascript
      await Book.create({
        title: '1984',
        author: 'George Orwell',
        publicationYear: 1949,
      });
      ```

---

- **READ (Ler)**: Buscar registros.
  - `Model.findAll()`: Retorna um array com todos os registros.
  - `Model.findByPk(id)`: Busca um registro pela sua chave prim√°ria (Primary Key).
  - `Model.findOne({ where: { ... } })`: Busca o primeiro registro que corresponda √† condi√ß√£o.
  - ```javascript
    // Buscar todos
    const allBooks = await Book.findAll();
    // Buscar por uma condi√ß√£o
    const orwellBook = await Book.findOne({
      where: { author: 'George Orwell' },
    });
    ```

---

- **UPDATE (Atualizar)**: Modificar um registro existente.
  - Usa o m√©todo `Model.update(dados, { where: { ... } })`.
  - O primeiro argumento √© um objeto com os novos dados.
  - O segundo argumento define _quais_ registros ser√£o atualizados.
  - ```javascript
    await Book.update(
      { publicationYear: 1950 }, // Novos dados
      { where: { title: '1984' } } // Condi√ß√£o
    );
    ```

---

- **DELETE (Deletar)**: Remover um registro.
  - Usa o m√©todo `Model.destroy({ where: { ... } })`.
  - A condi√ß√£o `where` √© crucial para n√£o apagar dados indesejados.
  - ```javascript
    await Book.destroy({
      where: { id: 1 },
    });
    ```

---

## ‚ö°Ô∏è 3. ORMs Alternativos: Prisma & TypeORM

- ### üÖøÔ∏è Prisma
  - **Abordagem "Schema First"**: A "fonte da verdade" √© um arquivo `schema.prisma`.
    - O schema define o banco de dados E o cliente que ser√° gerado.
    - **`schema.prisma` para Livros:**
      ```prisma
      model Book {
        id              Int      @id @default(autoincrement())
        isbn            String   @unique
        title           String
        author          String
        publicationYear Int?
      }
      ```

---

- **Cliente Totalmente Type-Safe**: Gera um cliente de banco de dados para JavaScript/TypeScript com tipagem autom√°tica.
  - Oferece um autocompletar excelente e previne erros em tempo de desenvolvimento.
  - `prisma.book.findMany({ where: { ... } })`
- **Migrations Expl√≠citas e Seguras**: Comandos como `prisma migrate dev` analisam o schema, geram o arquivo de migra√ß√£o SQL e o aplicam. √â mais seguro e control√°vel que `sync({ force: true })`.

---

- ### üÖæÔ∏è TypeORM
  - **Foco Principal em TypeScript**: Utiliza **Decorators** para definir entidades, uma sintaxe muito comum em outras linguagens como Java (Hibernate) e C# (Entity Framework).
  - **Padr√£o Repository ou Active Record**: Oferece flexibilidade de arquitetura.
    - **Repository**: Separa o modelo (`Entity`) da sua l√≥gica de persist√™ncia (`Repository`).

---

- **Defini√ß√£o da Entidade `Book`:**

  ```typescript
  import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

  @Entity()
  export class Book {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({ unique: true })
    isbn: string;

    @Column()
    title: string;

    @Column()
    author: string;
  }
  ```

---

## ‚öñÔ∏è 4. Conclus√£o e Quadro Comparativo

---

| Caracter√≠stica            | **Sequelize**                 | **TypeORM**                                      | **Prisma**                                       |
| ------------------------- | ----------------------------- | ------------------------------------------------ | ------------------------------------------------ |
| **Paradigma**             | Active Record (predominante)  | Active Record & Data Mapper (flex√≠vel)           | Schema First, com um cliente gerado              |
| **Linguagem**             | JavaScript (bom suporte a TS) | **TypeScript First**                             | Agn√≥stico (gera cliente para JS/TS)              |
| **Tipagem (TS)**          | Boa, mas muitas vezes manual  | **Excelente e Nativa**                           | **Excelente e Autom√°tica** (melhor da categoria) |
| **Curva de Aprendizagem** | Moderada                      | Moderada (exige conhecimento de TS e Decorators) | Baixa para Moderada (f√°cil de come√ßar)           |

---

| Caracter√≠stica    | **Sequelize**                                  | **TypeORM**                                                  | **Prisma**                                                                                                                 |
| ----------------- | ---------------------------------------------- | ------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| **Ideal Para...** | Projetos legados, JS puro, ecossistema maduro. | Projetos complexos em TS, equipes com background em Java/C#. | Novas aplica√ß√µes (especialmente serverless), projetos que priorizam a seguran√ßa de tipos e a experi√™ncia do desenvolvedor. |

https://docs.google.com/spreadsheets/d/1DHSGcN1QHK-QXmbaXzbSu4wWnejEFH-zt9ItnrvwU0E/edit?usp=sharing
