---
marp: true
theme: default
class: invert
paginate: true
---

# Conectando seu HTML a um Servidor
## ü•ë Usando a API do Rick and Morty

---

## üöÄ O que vamos aprender hoje?

* O que √© uma **API** (A Analogia do Gar√ßom).
* O que √© **JSON** e como ler os dados que o servidor nos envia.
* Como usar a fun√ß√£o `fetch()` do JavaScript para "pedir" dados.
* Como usar o **DOM** para exibir esses dados dinamicamente no seu HTML.

---

## üìã Pr√©-requisitos

Para esta aula, voc√™ s√≥ precisa de um conhecimento b√°sico em:

* **HTML:** Entender tags como `<div>`, `<h1>`, e `<script>`.
* **JavaScript:**
    * Vari√°veis (`const`, `let`)
    * Fun√ß√µes (`function() {}`)
    * Sele√ß√£o de elementos (`document.getElementById`)

---

## 1. O que √© uma API?
### (A Analogia do Gar√ßom)

* **Voc√™ (Cliente):** Sua p√°gina `HTML/JS`.
* **Cozinha (Servidor):** Onde os dados do Rick and Morty vivem.
* **Gar√ßom (API):** A interface que busca os dados para voc√™.

> Voc√™ n√£o vai at√© a cozinha. Voc√™ usa a **API** (`fetch`) para pedir ao **Servidor** pelos dados, e ele os traz para voc√™ (em **JSON**).

---

## 2. O que √© `fetch()`?
### (O Pedido)

* `fetch()` √© a fun√ß√£o moderna do JavaScript que "chama o gar√ßom".
* √â como voc√™ diz: "Ei, JS, v√° at√© esta URL e me traga o que tem l√°".
* `fetch()` √© **Ass√≠ncrono**: Ele n√£o para seu c√≥digo. Ele faz o pedido e te avisa "quando" a resposta chegar.
* Usamos `.then()` (ou `async/await`) para lidar com essa espera.

---

## 3. O que √© JSON?
### (O Card√°pio / A Resposta)

* O servidor n√£o responde com HTML. Ele responde com **JSON** (JavaScript Object Notation).
* √â um formato de texto universal para troca de dados.
* **A boa not√≠cia:** Ele se parece *exatamente* com um objeto JavaScript!

```json
{
  "info": { ... },
  "results": [
    {
      "id": 1,
      "name": "Rick Sanchez",
      "status": "Alive",
      "image": "[https://url.da.imagem/1.jpeg](https://url.da.imagem/1.jpeg)"
    },
    { ... }
  ]
}
````

-----

## ‚ö° Foco: Entendendo o `fetch()`

Vamos mergulhar fundo na ferramenta mais importante
para "conversar" com servidores.

-----

## O Telefone do JavaScript

Pense no `fetch()` como um **telefone**.
Uma liga√ß√£o n√£o √© instant√¢nea. Voc√™ precisa **esperar**.

1.  **Discar** (chamar `fetch`)
2.  **Esperar** atender (a `Promise` fica *pending*)
3.  Servidor **atende** (a `Promise` √© *fulfilled* com uma `Response`)
4.  **Pedir** a informa√ß√£o (chamar `.json()`)
5.  **Esperar** ele buscar (outra `Promise`)
6.  Ele **entrega** a informa√ß√£o (os `data`)

-----

## O que √© uma `Promise` (Promessa)?

`fetch()` n√£o retorna os dados. Ele retorna uma **`Promise`**.
√â um objeto que representa um valor que *ainda n√£o est√° pronto*.

  * **`pending` (Pendente):** A "liga√ß√£o" est√° chamando.
  * **`fulfilled` (Realizada):** Sucesso\! O servidor atendeu.
  * **`rejected` (Rejeitada):** Falha\! A "liga√ß√£o caiu" (erro de rede).

Usamos `.then()` para quando ela √© *realizada*.
Usamos `.catch()` para quando ela √© *rejeitada*.

-----

## Anatomia da Requisi√ß√£o (`.then()`)

Vamos dissecar o c√≥digo:

```js
fetch(API_URL)
    .then(response => {
        // ... Bloco 1: A Resposta HTTP ...
    })
    .then(data => {
        // ... Bloco 2: Os Dados JSON ...
    })
    .catch(error => {
        // ... Bloco 3: O Erro ...
    });
```

-----

## Bloco 1: A `Response`

O primeiro `.then()` **N√ÉO** recebe os dados. Ele recebe a "capa" da resposta.

```js
.then(response => {
    // 'response' tem o status:
    // response.status (ex: 200, 404, 500)
    // response.ok (true se status 200-299)
    
    // ... aqui verificamos se response.ok ...

    // Se ok, pedimos para ler os dados.
    // Isso retorna OUTRA PROMISSE!
    return response.json(); 
})
```

-----

## ‚ö†Ô∏è A Maior "Pegadinha" do `fetch()`

Um erro **404** (N√£o Encontrado) ou **500** (Erro de Servidor) **N√ÉO** dispara o `.catch()`\!

  * O `.catch()` s√≥ pega **erros de rede** (sem internet, DNS falhou).
  * Para o `fetch`, um 404 √© uma *resposta bem-sucedida* (o servidor atendeu e disse "n√£o achei").

**Por isso, este bloco √© ESSENCIAL:**

```js
if (!response.ok) {
    // response.ok √© false para 404, 500, etc.
    // N√≥s manualmente criamos um erro para pular para o .catch()
    throw new Error('HTTP status ' + response.status);
}
```

-----

## Bloco 2: Os Dados (`data`)

O segundo `.then()` espera a `Promise` do `response.json()` ser resolvida.

```js
.then(data => {
    // AGORA SIM!
    // 'data' √© o objeto JSON puro, pronto para usar.
    console.log(data.results);
    exibirPersonagens(data.results);
})
```

-----

## Bloco 3: O Erro (`.catch()`)

Este bloco ser√° executado se:

1.  O `fetch()` falhar (erro de rede, sem internet).
2.  N√≥s for√ßamos um erro no Bloco 1 (o `throw new Error`).

<!-- end list -->

```js
.catch(error => {
    console.error('Falha na requisi√ß√£o:', error);
});
```

-----

## A Forma Moderna: `async / await`

`.then().then()` pode ficar confuso.
`async/await` √© "a√ß√∫car sint√°tico" para fazer a **mesma coisa** de forma mais leg√≠vel.

-----

## `async / await` - O C√≥digo

```js
// 1. Marcamos a fun√ß√£o como 'async'
async function buscarPersonagensAsync() {
    // 6. 'try...catch' substitui o .catch()
    try {
        // 2. 'await' espera o fetch (substitui o 1¬∫ .then)
        const response = await fetch(API_URL);

        // 3. Verifica√ß√£o de erro (IGUALMENTE IMPORTANTE!)
        if (!response.ok) {
            throw new Error('Erro HTTP: ' + response.status);
        }

        // 4. 'await' espera o .json() (substitui o 2¬∫ .then)
        const data = await response.json();

        // 5. Agora temos os dados!
        exibirPersonagens(data.results);
    } catch (error) {
        console.error('Falha ao buscar personagens:', error);
    }
}
```

-----

## Comparativo: `.then()` vs `async/await`

| Caracter√≠stica | Sintaxe com `.then()` | Sintaxe com `async/await` |
| :--- | :--- | :--- |
| **Estrutura** | Aninhada (cadeia de `.then()`) | "Plana", c√≥digo s√≠ncrono |
| **Obten√ß√£o de Dados** | `response.json().then(data => ...)` | `const data = await response.json()` |
| **Tratamento de Erros** | `.catch(error => ...)` | `try { ... } catch (error) { ... }` |

**Ambos fazem a *mesma coisa*. `async/await` √© geralmente mais f√°cil de ler.**

-----

## üîß M√£os √† Obra\!

Agora que entendemos o `fetch`, vamos montar nossa p√°gina.

1.  **HTML:** O esqueleto.
2.  **CSS:** A apar√™ncia.
3.  **JS:** A m√°gica (`fetch` + DOM).

-----

## `index.html`

O HTML √© simples. O mais importante √© o `<main id="personagens-container">`, que √© onde o JS vai "desenhar" os cards, e o `<script>` no final.

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <title>Portal do Rick and Morty</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Personagens de Rick and Morty</h1>

    <main id="personagens-container" class="container">
        </main>

    <script src="app.js"></script>
</body>
</html>
```

-----

## `style.css`

Vamos focar no layout dos cards. Usaremos `flexbox` para organizar.

---

```css
body {
    background-color: #272B33;
    color: #F5F5F5;
    font-family: sans-serif;
}
.container {
    display: flex;
    flex-wrap: wrap; /* Permite quebrar a linha */
    justify-content: center;
    gap: 20px;
}
.card {
    background-color: #3C3E44;
    border-radius: 10px;
    overflow: hidden;
    width: 280px;
}
.card img {
    width: 100%;
}
.card-info {
    padding: 15px;
}
```

-----

## `app.js` (Buscando os Dados)

Aqui n√≥s fazemos o `fetch` e tratamos a resposta.

```javascript
const API_URL = 'https://rickandmortyapi.com/api/character';

window.addEventListener('DOMContentLoaded', () => {
    buscarPersonagens();
});

function buscarPersonagens() {
    fetch(API_URL)
        .then(response => {
            if (!response.ok) { // Importante: Checagem de erro!
                throw new Error('Erro HTTP: ' + response.status);
            }
            return response.json();
        })
        .then(data => {
            exibirPersonagens(data.results);
        })
        .catch(error => {
            console.error('Falha ao buscar personagens:', error);
        });
}
```

-----

## `app.js` (Alternativa com `async/await`)

Veja como o c√≥digo de busca fica mais "limpo" com `async/await`.

---

```javascript
const API_URL = 'https://rickandmortyapi.com/api/character';

window.addEventListener('DOMContentLoaded', () => {
    buscarPersonagensAsync(); // Chamamos a vers√£o async
});

async function buscarPersonagensAsync() {
    try {
        const response = await fetch(API_URL);
        if (!response.ok) {
            throw new Error('Erro HTTP: ' + response.status);
        }
        const data = await response.json();
        exibirPersonagens(data.results); // Mesma fun√ß√£o de antes!
    } catch (error) {
        console.error('Falha ao buscar personagens:', error);
    }
}
```

-----

## `app.js` (Exibindo no DOM)

Esta fun√ß√£o **√© a mesma para ambas as abordagens** (`.then` ou `async`).
Ela recebe o array de personagens e cria o HTML.

---
```javascript
function exibirPersonagens(personagens) {
    const container = document.getElementById('personagens-container');

    // Usamos 'map' para transformar CADA personagem em uma string HTML
    const htmlPersonagens = personagens.map(personagem => {
        return `
            <article class="card">
                <img src="${personagem.image}" alt="${personagem.name}">
                <div class="card-info">
                    <h3>${personagem.name}</h3>
                    <p>Status: ${personagem.status}</p>
                    <p>Esp√©cie: ${personagem.species}</p>
                </div>
            </article>
        `;
    }).join(''); // Junta todas as strings em uma s√≥

    // Insere o HTML gigante no container de uma vez
    container.innerHTML = htmlPersonagens;
}
```

-----

## üéì Resumo da Aula

1.  O **HTML** carrega (vazio).
2.  O **JavaScript** √© executado.
3.  O `fetch()` "pede" os dados √† API (retorna uma `Promise`).
4.  O `await` (ou `.then()`) espera a `Response`.
5.  Verificamos se `response.ok` √© `true`.
6.  O `await` (ou `.then()`) espera o `.json()` (outra `Promise`).
7.  Os `data` chegam e chamamos `exibirPersonagens()`.
8.  O `innerHTML` insere os cards na p√°gina.

**Sua p√°gina, antes est√°tica, agora est√° VIVA com dados de um servidor\!**

-----

## üèÜ Pr√≥ximos Passos (Trabalho valendo 3,0 pontos)

  * **Pagina√ß√£o:** A API envia os dados em p√°ginas. Como buscar a `page=2`? (Dica: a API envia um link `data.info.next`).
  * **Barra de Busca:** Adicionar um `<input>` e filtrar os personagens pelo nome.
  * **Detalhes:** Criar uma p√°gina que mostra os detalhes de UM personagem espec√≠fico ao clicar no card.

-----


## D√∫vidas?
